// Helper functions for authorizing with FFLogs using the PKCE code exchange flow.
// See documentation: https://www.fflogs.com/api/docs

// client IDs generated by shanzhe; no secrets exist since keys are PKCE-only
const CLIENT_ID =
	window.location.hostname === "xivintheshell.com"
		? "a023d800-1740-426a-8134-915efc395aa3"
		: window.location.hostname === "beta.xivintheshell.com"
			? "a0281008-3d39-4afc-81b4-a8ddbf7cbd44"
			: // Dev key authorized for localhost:3000 (vite start)
				window.location.host === "localhost:3000"
				? "a028101a-803b-4ad4-99b6-bacb8484e214"
				: // ...and for and localhost:4173 (vite preview)
					// These keys must be separate because they cannot share PKCE secrets, which are persisted
					// in localStorage for each host.
					window.location.host === "localhost:4173"
					? "a0281237-7471-47d4-b33c-52a6cbaed4c1"
					: // Any other domain has no key. If you're deploying a fork, you should generate your own key
						// and set it here.
						"";

const AUTH_ENDPOINT = "https://www.fflogs.com/oauth/authorize";
const TOKEN_ENDPOINT = "https://www.fflogs.com/oauth/token";

// === AUTHORIZATION ===
// PKCE flow https://stackoverflow.com/a/63336562
// (helper functions partly generated with gemini)
function generateCodeVerifier(): string {
	const array = new Uint8Array(128 / 2);
	window.crypto.getRandomValues(array);
	return Array.from(array, (n) => n.toString(16).padStart(2, "0")).join("");
}

async function generateCodeChallenge(verifier: string): Promise<string> {
	const encoder = new TextEncoder();
	const data = encoder.encode(verifier);
	const digest = await window.crypto.subtle.digest("SHA-256", data);
	const base64 = btoa(String.fromCharCode(...new Uint8Array(digest)));
	return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

const LOCALSTORAGE_PKCE_VERIFIER = "pkceCodeVerifier";
const LOCALSTORAGE_PKCE_STATE_BLOB = "pkceStateBlob";

/**
 * Complete a PKCE code authorization sequence to retrieve a token from FFLogs.
 * This redirects the user to www.fflogs.com, which will redirect with  code+state URL parameters.
 * upon successful authorization.
 *
 * The PKCE verifier and state blob should be persisted in localStorage to ensure we don't generate
 * a million tokens.
 */
export async function initiateFflogsAuth() {
	// TODO find some way to hit cn endpoint for cn users?
	const verifier = generateCodeVerifier();
	const challenge = await generateCodeChallenge(verifier);
	const pkceStateBlob = window.crypto.randomUUID();
	if (localStorage.getItem(LOCALSTORAGE_PKCE_VERIFIER) === null) {
		window.localStorage.setItem(LOCALSTORAGE_PKCE_VERIFIER, verifier);
	}
	if (window.localStorage.getItem(LOCALSTORAGE_PKCE_STATE_BLOB) === null) {
		window.localStorage.setItem(LOCALSTORAGE_PKCE_STATE_BLOB, pkceStateBlob);
	}
	const params = new URLSearchParams({
		client_id: CLIENT_ID,
		code_challenge: challenge,
		code_challenge_method: "S256",
		state: pkceStateBlob,
		// Since we're an SPA, we just redirect back to ourselves.
		// Instead of hard-coding the URL, using window.location.origin covers
		// the main, beta, and localhost testing sites.
		redirect_uri: window.location.origin,
		response_type: "code",
	});
	// Redirect user to auth page
	window.location.href = `${AUTH_ENDPOINT}?${params.toString()}`;
}

function clearPKCEAuthState() {
	window.localStorage.removeItem(LOCALSTORAGE_PKCE_VERIFIER);
	window.localStorage.removeItem(LOCALSTORAGE_PKCE_STATE_BLOB);
}

export enum AccessTokenStatus {
	UNAUTHORIZED,
	NO_PKCE_VERIFIER,
	BAD_PKCE_STATE,
	SUCCESS,
	FAILURE,
}

/**
 * Handle a redirect from the FFLogs authorization API. This function is run when the
 * page is loaded with the `code` search parameter, indicating a response from the PKCE
 * authorization flow.
 *
 * This function is stateful, and will remove any URL parameters from window.history.
 *
 * After this function succeeds, "fflogsAuthToken" will be populated in window.sessionStorage.
 */
export async function getAccessToken(): Promise<AccessTokenStatus> {
	const searchParams = new URLSearchParams(window.location.search);
	// Remove the code + state PKCE flow parameters from the URL now that we've parsed them.
	window.history.replaceState({}, "", window.location.pathname);
	const authCode = searchParams.get("code");
	const verifier = window.localStorage.getItem(LOCALSTORAGE_PKCE_VERIFIER);
	const expectedState = window.localStorage.getItem(LOCALSTORAGE_PKCE_STATE_BLOB);
	if (!authCode) {
		return AccessTokenStatus.UNAUTHORIZED;
	}
	if (!verifier) {
		console.error("PKCE verifier could not be retrieved");
		clearPKCEAuthState();
		return AccessTokenStatus.NO_PKCE_VERIFIER;
	}
	if (searchParams.get("state") !== expectedState) {
		console.error("PKCE response did not have expected state; resetting flow");
		console.log("expected:", expectedState);
		console.log("actual:", searchParams.get("state"));
		clearPKCEAuthState();
		return AccessTokenStatus.BAD_PKCE_STATE;
	}
	const tokenParams = new URLSearchParams({
		client_id: CLIENT_ID,
		code_verifier: verifier,
		redirect_uri: window.location.origin,
		grant_type: "authorization_code",
		code: authCode,
	});
	try {
		const response = await fetch(TOKEN_ENDPOINT, {
			method: "POST",
			headers: {
				"Content-Type": "application/x-www-form-urlencoded",
			},
			body: tokenParams.toString(),
		});
		if (response.ok) {
			const tokens = await response.json();
			// TODO handle refresh_token?
			window.sessionStorage.setItem("fflogsAuthToken", tokens["access_token"]);
			console.log("saved auth tokens to sessionStorage");
			return AccessTokenStatus.SUCCESS;
		} else {
			console.log("PKCE response was not ok; clearing intermediate state");
			console.error(response);
			clearPKCEAuthState();
			return AccessTokenStatus.FAILURE;
		}
	} catch (e) {
		console.log("PKCE exchange failed; clearing intermediate state");
		console.error(e);
		clearPKCEAuthState();
		return AccessTokenStatus.FAILURE;
	}
}
