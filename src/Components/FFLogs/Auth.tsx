// client ID generated by shanzhe; no secret exists since it's PKCE-only
const CLIENT_ID = "a023d800-1740-426a-8134-915efc395aa3";
const AUTH_ENDPOINT = "https://www.fflogs.com/oauth/authorize";
const TOKEN_ENDPOINT = "https://www.fflogs.com/oauth/token";

// === AUTHORIZATION ===
// PKCE flow https://stackoverflow.com/a/63336562
// (helper functions partly generated with gemini)
function generateCodeVerifier(): string {
	const array = new Uint8Array(128 / 2);
	window.crypto.getRandomValues(array);
	return Array.from(array, (n) => n.toString(16).padStart(2, "0")).join("");
}

async function generateCodeChallenge(verifier: string): Promise<string> {
	const encoder = new TextEncoder();
	const data = encoder.encode(verifier);
	const digest = await window.crypto.subtle.digest("SHA-256", data);
	const base64 = btoa(String.fromCharCode(...new Uint8Array(digest)));
	return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

const SESSIONSTORAGE_PKCE_VERIFIER = "pkceCodeVerifier";
const SESSIONSTORAGE_PKCE_STATE_BLOB = "pkceStateBlob";

/**
 * Complete a PKCE code authorization sequence to retrieve a token from FFLogs.
 * This redirects the user to www.fflogs.com.
 */
export async function initiateFflogsAuth() {
	// TODO find some way to hit cn endpoint for cn users?
	const verifier = generateCodeVerifier();
	const challenge = await generateCodeChallenge(verifier);
	const pkceStateBlob = window.crypto.randomUUID();
	window.sessionStorage.setItem(SESSIONSTORAGE_PKCE_VERIFIER, verifier);
	window.sessionStorage.setItem(SESSIONSTORAGE_PKCE_STATE_BLOB, pkceStateBlob);
	const params = new URLSearchParams({
		client_id: CLIENT_ID,
		code_challenge: challenge,
		code_challenge_method: "S256",
		state: pkceStateBlob,
		// Since we're an SPA, we just redirect back to ourselves.
		// Instead of hard-coding the URL, using window.location.origin covers
		// the main, beta, and localhost testing sites.
		redirect_uri: window.location.origin,
		response_type: "code",
	});
	// Redirect user to auth page
	window.location.href = `${AUTH_ENDPOINT}?${params.toString()}`;
}

function clearTempAuthState() {
	window.sessionStorage.removeItem(SESSIONSTORAGE_PKCE_VERIFIER);
	window.sessionStorage.removeItem(SESSIONSTORAGE_PKCE_STATE_BLOB);
}

export enum AccessTokenStatus {
	UNAUTHORIZED,
	NO_PKCE_VERIFIER,
	BAD_PKCE_STATE,
	SUCCESS,
	FAILURE,
}

/**
 * Handle a redirect from the FFLogs authorization API. This function is run when the
 * page is loaded with the `code` search parameter, indicating a response from the PKCE
 * authorization flow.
 *
 * This function is stateful, and will remove any URL parameters from window.history.
 *
 * After this function succeeds, "fflogsAuthToken" will be populated in window.sessionStorage.
 */
export async function getAccessToken(): Promise<AccessTokenStatus> {
	const searchParams = new URLSearchParams(window.location.search);
	// Remove the code + state PKCE flow parameters from the URL now that we've parsed them.
	window.history.replaceState({}, "", window.location.pathname);
	const authCode = searchParams.get("code");
	const verifier = window.sessionStorage.getItem(SESSIONSTORAGE_PKCE_VERIFIER);
	const expectedState = window.sessionStorage.getItem(SESSIONSTORAGE_PKCE_STATE_BLOB);
	if (!authCode) {
		return AccessTokenStatus.UNAUTHORIZED;
	}
	if (!verifier) {
		console.error("PKCE verifier could not be retrieved");
		clearTempAuthState();
		return AccessTokenStatus.NO_PKCE_VERIFIER;
	}
	if (searchParams.get("state") !== expectedState) {
		console.error("PKCE response did not have expected state; resetting flow");
		clearTempAuthState();
		return AccessTokenStatus.BAD_PKCE_STATE;
	}
	const tokenParams = new URLSearchParams({
		client_id: CLIENT_ID,
		code_verifier: verifier,
		redirect_uri: window.location.origin,
		grant_type: "authorization_code",
		code: authCode,
	});
	try {
		const response = await fetch(TOKEN_ENDPOINT, {
			method: "POST",
			headers: {
				"Content-Type": "application/x-www-form-urlencoded",
			},
			body: tokenParams.toString(),
		});
		if (response.ok) {
			const tokens = await response.json();
			// TODO handle refresh_token?
			window.sessionStorage.setItem("fflogsAuthToken", tokens["access_token"]);
			console.log("saved auth tokens to sessionStorage");
			return AccessTokenStatus.SUCCESS;
		} else {
			console.log("PKCE response was not ok; clearing intermediate state");
			console.error(response);
			clearTempAuthState();
			return AccessTokenStatus.FAILURE;
		}
	} catch (e) {
		console.log("PKCE exchange failed; clearing intermediate state");
		console.error(e);
		clearTempAuthState();
		return AccessTokenStatus.FAILURE;
	}
}
